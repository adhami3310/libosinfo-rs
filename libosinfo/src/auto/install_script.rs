// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

#[cfg(feature = "v1_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
use crate::Tree;
use crate::{
    AvatarFormat, DeviceDriverSigningReq, Entity, InstallConfig, InstallConfigParam,
    InstallConfigParamList, InstallScriptInjectionMethod, InstallScriptInstallationSource, Media,
    Os, PathFormat,
};
use glib::{
    prelude::*,
    signal::{connect_raw, SignalHandlerId},
    translate::*,
};
use std::{boxed::Box as Box_, fmt, mem::transmute, pin::Pin, ptr};

glib::wrapper! {
    #[doc(alias = "OsinfoInstallScript")]
    pub struct InstallScript(Object<ffi::OsinfoInstallScript, ffi::OsinfoInstallScriptClass>) @extends Entity;

    match fn {
        type_ => || ffi::osinfo_install_script_get_type(),
    }
}

impl InstallScript {
    pub const NONE: Option<&'static InstallScript> = None;

    #[doc(alias = "osinfo_install_script_new")]
    pub fn new(id: &str) -> InstallScript {
        assert_initialized_main_thread!();
        unsafe { from_glib_full(ffi::osinfo_install_script_new(id.to_glib_none().0)) }
    }

    #[doc(alias = "osinfo_install_script_new_data")]
    pub fn new_data(id: &str, profile: &str, templateData: &str) -> InstallScript {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::osinfo_install_script_new_data(
                id.to_glib_none().0,
                profile.to_glib_none().0,
                templateData.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_new_uri")]
    pub fn new_uri(id: &str, profile: &str, templateUri: &str) -> InstallScript {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::osinfo_install_script_new_uri(
                id.to_glib_none().0,
                profile.to_glib_none().0,
                templateUri.to_glib_none().0,
            ))
        }
    }

    // rustdoc-stripper-ignore-next
    /// Creates a new builder-pattern struct instance to construct [`InstallScript`] objects.
    ///
    /// This method returns an instance of [`InstallScriptBuilder`](crate::builders::InstallScriptBuilder) which can be used to create [`InstallScript`] objects.
    pub fn builder() -> InstallScriptBuilder {
        InstallScriptBuilder::new()
    }
}

impl Default for InstallScript {
    fn default() -> Self {
        glib::object::Object::new::<Self>()
    }
}

// rustdoc-stripper-ignore-next
/// A [builder-pattern] type to construct [`InstallScript`] objects.
///
/// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct InstallScriptBuilder {
    builder: glib::object::ObjectBuilder<'static, InstallScript>,
}

impl InstallScriptBuilder {
    fn new() -> Self {
        Self {
            builder: glib::object::Object::builder(),
        }
    }

    pub fn preferred_injection_method(
        self,
        preferred_injection_method: InstallScriptInjectionMethod,
    ) -> Self {
        Self {
            builder: self
                .builder
                .property("preferred-injection-method", preferred_injection_method),
        }
    }

    pub fn profile(self, profile: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("profile", profile.into()),
        }
    }

    pub fn template_data(self, template_data: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("template-data", template_data.into()),
        }
    }

    pub fn template_uri(self, template_uri: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("template-uri", template_uri.into()),
        }
    }

    pub fn id(self, id: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("id", id.into()),
        }
    }

    // rustdoc-stripper-ignore-next
    /// Build the [`InstallScript`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> InstallScript {
        self.builder.build()
    }
}

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::InstallScript>> Sealed for T {}
}

pub trait InstallScriptExt: IsA<InstallScript> + sealed::Sealed + 'static {
    #[doc(alias = "osinfo_install_script_generate")]
    fn generate(
        &self,
        os: &impl IsA<Os>,
        config: &impl IsA<InstallConfig>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<glib::GString, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::osinfo_install_script_generate(
                self.as_ref().to_glib_none().0,
                os.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "osinfo_install_script_generate_async")]
    fn generate_async<P: FnOnce(Result<glib::GString, glib::Error>) + 'static>(
        &self,
        os: &impl IsA<Os>,
        config: &impl IsA<InstallConfig>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn generate_async_trampoline<
            P: FnOnce(Result<glib::GString, glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let ret = ffi::osinfo_install_script_generate_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = generate_async_trampoline::<P>;
        unsafe {
            ffi::osinfo_install_script_generate_async(
                self.as_ref().to_glib_none().0,
                os.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn generate_future(
        &self,
        os: &(impl IsA<Os> + Clone + 'static),
        config: &(impl IsA<InstallConfig> + Clone + 'static),
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<glib::GString, glib::Error>> + 'static>>
    {
        let os = os.clone();
        let config = config.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.generate_async(&os, &config, Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    #[doc(alias = "osinfo_install_script_generate_command_line")]
    fn generate_command_line(
        &self,
        os: &impl IsA<Os>,
        config: &impl IsA<InstallConfig>,
    ) -> glib::GString {
        unsafe {
            from_glib_full(ffi::osinfo_install_script_generate_command_line(
                self.as_ref().to_glib_none().0,
                os.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_generate_command_line_for_media")]
    fn generate_command_line_for_media(
        &self,
        media: &impl IsA<Media>,
        config: &impl IsA<InstallConfig>,
    ) -> glib::GString {
        unsafe {
            from_glib_full(ffi::osinfo_install_script_generate_command_line_for_media(
                self.as_ref().to_glib_none().0,
                media.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "osinfo_install_script_generate_command_line_for_tree")]
    fn generate_command_line_for_tree(
        &self,
        tree: &impl IsA<Tree>,
        config: &impl IsA<InstallConfig>,
    ) -> glib::GString {
        unsafe {
            from_glib_full(ffi::osinfo_install_script_generate_command_line_for_tree(
                self.as_ref().to_glib_none().0,
                tree.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_generate_for_media")]
    fn generate_for_media(
        &self,
        media: &impl IsA<Media>,
        config: &impl IsA<InstallConfig>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<glib::GString, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::osinfo_install_script_generate_for_media(
                self.as_ref().to_glib_none().0,
                media.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "osinfo_install_script_generate_for_media_async")]
    fn generate_for_media_async<P: FnOnce(Result<glib::GString, glib::Error>) + 'static>(
        &self,
        media: &impl IsA<Media>,
        config: &impl IsA<InstallConfig>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn generate_for_media_async_trampoline<
            P: FnOnce(Result<glib::GString, glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let ret = ffi::osinfo_install_script_generate_for_media_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = generate_for_media_async_trampoline::<P>;
        unsafe {
            ffi::osinfo_install_script_generate_for_media_async(
                self.as_ref().to_glib_none().0,
                media.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn generate_for_media_future(
        &self,
        media: &(impl IsA<Media> + Clone + 'static),
        config: &(impl IsA<InstallConfig> + Clone + 'static),
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<glib::GString, glib::Error>> + 'static>>
    {
        let media = media.clone();
        let config = config.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.generate_for_media_async(&media, &config, Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "osinfo_install_script_generate_for_tree")]
    fn generate_for_tree(
        &self,
        tree: &impl IsA<Tree>,
        config: &impl IsA<InstallConfig>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<glib::GString, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::osinfo_install_script_generate_for_tree(
                self.as_ref().to_glib_none().0,
                tree.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "osinfo_install_script_generate_for_tree_async")]
    fn generate_for_tree_async<P: FnOnce(Result<glib::GString, glib::Error>) + 'static>(
        &self,
        tree: &impl IsA<Tree>,
        config: &impl IsA<InstallConfig>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn generate_for_tree_async_trampoline<
            P: FnOnce(Result<glib::GString, glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let ret = ffi::osinfo_install_script_generate_for_tree_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = generate_for_tree_async_trampoline::<P>;
        unsafe {
            ffi::osinfo_install_script_generate_for_tree_async(
                self.as_ref().to_glib_none().0,
                tree.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    fn generate_for_tree_future(
        &self,
        tree: &(impl IsA<Tree> + Clone + 'static),
        config: &(impl IsA<InstallConfig> + Clone + 'static),
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<glib::GString, glib::Error>> + 'static>>
    {
        let tree = tree.clone();
        let config = config.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.generate_for_tree_async(&tree, &config, Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    #[doc(alias = "osinfo_install_script_generate_output")]
    fn generate_output(
        &self,
        os: &impl IsA<Os>,
        config: &impl IsA<InstallConfig>,
        output_dir: &impl IsA<gio::File>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<gio::File, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::osinfo_install_script_generate_output(
                self.as_ref().to_glib_none().0,
                os.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
                output_dir.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "osinfo_install_script_generate_output_async")]
    fn generate_output_async<P: FnOnce(Result<gio::File, glib::Error>) + 'static>(
        &self,
        os: &impl IsA<Os>,
        config: &impl IsA<InstallConfig>,
        output_dir: &impl IsA<gio::File>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn generate_output_async_trampoline<
            P: FnOnce(Result<gio::File, glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let ret = ffi::osinfo_install_script_generate_output_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = generate_output_async_trampoline::<P>;
        unsafe {
            ffi::osinfo_install_script_generate_output_async(
                self.as_ref().to_glib_none().0,
                os.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
                output_dir.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn generate_output_future(
        &self,
        os: &(impl IsA<Os> + Clone + 'static),
        config: &(impl IsA<InstallConfig> + Clone + 'static),
        output_dir: &(impl IsA<gio::File> + Clone + 'static),
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<gio::File, glib::Error>> + 'static>> {
        let os = os.clone();
        let config = config.clone();
        let output_dir = output_dir.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.generate_output_async(&os, &config, &output_dir, Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    #[doc(alias = "osinfo_install_script_generate_output_for_media")]
    fn generate_output_for_media(
        &self,
        media: &impl IsA<Media>,
        config: &impl IsA<InstallConfig>,
        output_dir: &impl IsA<gio::File>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<gio::File, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::osinfo_install_script_generate_output_for_media(
                self.as_ref().to_glib_none().0,
                media.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
                output_dir.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "osinfo_install_script_generate_output_for_media_async")]
    fn generate_output_for_media_async<P: FnOnce(Result<gio::File, glib::Error>) + 'static>(
        &self,
        media: &impl IsA<Media>,
        config: &impl IsA<InstallConfig>,
        output_dir: &impl IsA<gio::File>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn generate_output_for_media_async_trampoline<
            P: FnOnce(Result<gio::File, glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let ret = ffi::osinfo_install_script_generate_output_for_media_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = generate_output_for_media_async_trampoline::<P>;
        unsafe {
            ffi::osinfo_install_script_generate_output_for_media_async(
                self.as_ref().to_glib_none().0,
                media.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
                output_dir.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn generate_output_for_media_future(
        &self,
        media: &(impl IsA<Media> + Clone + 'static),
        config: &(impl IsA<InstallConfig> + Clone + 'static),
        output_dir: &(impl IsA<gio::File> + Clone + 'static),
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<gio::File, glib::Error>> + 'static>> {
        let media = media.clone();
        let config = config.clone();
        let output_dir = output_dir.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.generate_output_for_media_async(
                &media,
                &config,
                &output_dir,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "osinfo_install_script_generate_output_for_tree")]
    fn generate_output_for_tree(
        &self,
        tree: &impl IsA<Tree>,
        config: &impl IsA<InstallConfig>,
        output_dir: &impl IsA<gio::File>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<gio::File, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::osinfo_install_script_generate_output_for_tree(
                self.as_ref().to_glib_none().0,
                tree.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
                output_dir.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    #[doc(alias = "osinfo_install_script_generate_output_for_tree_async")]
    fn generate_output_for_tree_async<P: FnOnce(Result<gio::File, glib::Error>) + 'static>(
        &self,
        tree: &impl IsA<Tree>,
        config: &impl IsA<InstallConfig>,
        output_dir: &impl IsA<gio::File>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn generate_output_for_tree_async_trampoline<
            P: FnOnce(Result<gio::File, glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = ptr::null_mut();
            let ret = ffi::osinfo_install_script_generate_output_for_tree_finish(
                _source_object as *mut _,
                res,
                &mut error,
            );
            let result = if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = generate_output_for_tree_async_trampoline::<P>;
        unsafe {
            ffi::osinfo_install_script_generate_output_for_tree_async(
                self.as_ref().to_glib_none().0,
                tree.as_ref().to_glib_none().0,
                config.as_ref().to_glib_none().0,
                output_dir.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    #[cfg(feature = "v1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_6")))]
    fn generate_output_for_tree_future(
        &self,
        tree: &(impl IsA<Tree> + Clone + 'static),
        config: &(impl IsA<InstallConfig> + Clone + 'static),
        output_dir: &(impl IsA<gio::File> + Clone + 'static),
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<gio::File, glib::Error>> + 'static>> {
        let tree = tree.clone();
        let config = config.clone();
        let output_dir = output_dir.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.generate_output_for_tree_async(
                &tree,
                &config,
                &output_dir,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    #[doc(alias = "osinfo_install_script_get_avatar_format")]
    #[doc(alias = "get_avatar_format")]
    fn avatar_format(&self) -> AvatarFormat {
        unsafe {
            from_glib_none(ffi::osinfo_install_script_get_avatar_format(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_can_post_install_drivers")]
    #[doc(alias = "get_can_post_install_drivers")]
    fn can_post_install_drivers(&self) -> bool {
        unsafe {
            from_glib(ffi::osinfo_install_script_get_can_post_install_drivers(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_can_pre_install_drivers")]
    #[doc(alias = "get_can_pre_install_drivers")]
    fn can_pre_install_drivers(&self) -> bool {
        unsafe {
            from_glib(ffi::osinfo_install_script_get_can_pre_install_drivers(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_config_param")]
    #[doc(alias = "get_config_param")]
    fn config_param(&self, name: &str) -> InstallConfigParam {
        unsafe {
            from_glib_full(ffi::osinfo_install_script_get_config_param(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_config_param_list")]
    #[doc(alias = "get_config_param_list")]
    fn config_param_list(&self) -> Vec<InstallScript> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(
                ffi::osinfo_install_script_get_config_param_list(self.as_ref().to_glib_none().0),
            )
        }
    }

    #[doc(alias = "osinfo_install_script_get_config_params")]
    #[doc(alias = "get_config_params")]
    fn config_params(&self) -> InstallConfigParamList {
        unsafe {
            from_glib_none(ffi::osinfo_install_script_get_config_params(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_expected_filename")]
    #[doc(alias = "get_expected_filename")]
    fn expected_filename(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::osinfo_install_script_get_expected_filename(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_injection_methods")]
    #[doc(alias = "get_injection_methods")]
    fn injection_methods(&self) -> InstallScriptInjectionMethod {
        unsafe {
            from_glib(ffi::osinfo_install_script_get_injection_methods(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[cfg(feature = "v1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_3")))]
    #[doc(alias = "osinfo_install_script_get_installation_source")]
    #[doc(alias = "get_installation_source")]
    fn installation_source(&self) -> InstallScriptInstallationSource {
        unsafe {
            from_glib(ffi::osinfo_install_script_get_installation_source(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_needs_internet")]
    #[doc(alias = "get_needs_internet")]
    fn needs_internet(&self) -> bool {
        unsafe {
            from_glib(ffi::osinfo_install_script_get_needs_internet(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_output_filename")]
    #[doc(alias = "get_output_filename")]
    fn output_filename(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::osinfo_install_script_get_output_filename(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_output_prefix")]
    #[doc(alias = "get_output_prefix")]
    fn output_prefix(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::osinfo_install_script_get_output_prefix(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_path_format")]
    #[doc(alias = "get_path_format")]
    fn path_format(&self) -> PathFormat {
        unsafe {
            from_glib(ffi::osinfo_install_script_get_path_format(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_post_install_drivers_signing_req")]
    #[doc(alias = "get_post_install_drivers_signing_req")]
    fn post_install_drivers_signing_req(&self) -> DeviceDriverSigningReq {
        unsafe {
            from_glib(
                ffi::osinfo_install_script_get_post_install_drivers_signing_req(
                    self.as_ref().to_glib_none().0,
                ),
            )
        }
    }

    #[doc(alias = "osinfo_install_script_get_pre_install_drivers_signing_req")]
    #[doc(alias = "get_pre_install_drivers_signing_req")]
    fn pre_install_drivers_signing_req(&self) -> DeviceDriverSigningReq {
        unsafe {
            from_glib(
                ffi::osinfo_install_script_get_pre_install_drivers_signing_req(
                    self.as_ref().to_glib_none().0,
                ),
            )
        }
    }

    #[cfg(feature = "v1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_3")))]
    #[doc(alias = "osinfo_install_script_get_preferred_injection_method")]
    #[doc(alias = "get_preferred_injection_method")]
    fn preferred_injection_method(&self) -> InstallScriptInjectionMethod {
        unsafe {
            from_glib(ffi::osinfo_install_script_get_preferred_injection_method(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_product_key_format")]
    #[doc(alias = "get_product_key_format")]
    fn product_key_format(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::osinfo_install_script_get_product_key_format(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_profile")]
    #[doc(alias = "get_profile")]
    fn profile(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::osinfo_install_script_get_profile(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_template_data")]
    #[doc(alias = "get_template_data")]
    fn template_data(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::osinfo_install_script_get_template_data(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_get_template_uri")]
    #[doc(alias = "get_template_uri")]
    fn template_uri(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::osinfo_install_script_get_template_uri(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_has_config_param")]
    fn has_config_param(&self, config_param: &impl IsA<InstallConfigParam>) -> bool {
        unsafe {
            from_glib(ffi::osinfo_install_script_has_config_param(
                self.as_ref().to_glib_none().0,
                config_param.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "osinfo_install_script_has_config_param_name")]
    fn has_config_param_name(&self, name: &str) -> bool {
        unsafe {
            from_glib(ffi::osinfo_install_script_has_config_param_name(
                self.as_ref().to_glib_none().0,
                name.to_glib_none().0,
            ))
        }
    }

    #[cfg(feature = "v1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_3")))]
    #[doc(alias = "osinfo_install_script_set_installation_source")]
    fn set_installation_source(&self, source: InstallScriptInstallationSource) {
        unsafe {
            ffi::osinfo_install_script_set_installation_source(
                self.as_ref().to_glib_none().0,
                source.into_glib(),
            );
        }
    }

    #[doc(alias = "osinfo_install_script_set_output_prefix")]
    fn set_output_prefix(&self, prefix: &str) {
        unsafe {
            ffi::osinfo_install_script_set_output_prefix(
                self.as_ref().to_glib_none().0,
                prefix.to_glib_none().0,
            );
        }
    }

    #[cfg(feature = "v1_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_3")))]
    #[doc(alias = "osinfo_install_script_set_preferred_injection_method")]
    fn set_preferred_injection_method(&self, method: InstallScriptInjectionMethod) {
        unsafe {
            ffi::osinfo_install_script_set_preferred_injection_method(
                self.as_ref().to_glib_none().0,
                method.into_glib(),
            );
        }
    }

    #[doc(alias = "installation-source")]
    fn get_property_installation_source(&self) -> InstallScriptInstallationSource {
        glib::ObjectExt::property(self.as_ref(), "installation-source")
    }

    #[doc(alias = "preferred-injection-method")]
    fn get_property_preferred_injection_method(&self) -> InstallScriptInjectionMethod {
        glib::ObjectExt::property(self.as_ref(), "preferred-injection-method")
    }

    #[doc(alias = "preferred-injection-method")]
    fn set_property_preferred_injection_method(
        &self,
        preferred_injection_method: InstallScriptInjectionMethod,
    ) {
        glib::ObjectExt::set_property(
            self.as_ref(),
            "preferred-injection-method",
            preferred_injection_method,
        )
    }

    #[doc(alias = "avatar-format")]
    fn connect_avatar_format_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_avatar_format_trampoline<
            P: IsA<InstallScript>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::OsinfoInstallScript,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(InstallScript::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::avatar-format\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_avatar_format_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "installation-source")]
    fn connect_installation_source_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_installation_source_trampoline<
            P: IsA<InstallScript>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::OsinfoInstallScript,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(InstallScript::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::installation-source\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_installation_source_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "path-format")]
    fn connect_path_format_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_path_format_trampoline<
            P: IsA<InstallScript>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::OsinfoInstallScript,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(InstallScript::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::path-format\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_path_format_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "preferred-injection-method")]
    fn connect_preferred_injection_method_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_preferred_injection_method_trampoline<
            P: IsA<InstallScript>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::OsinfoInstallScript,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(InstallScript::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::preferred-injection-method\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_preferred_injection_method_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "product-key-format")]
    fn connect_product_key_format_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_product_key_format_trampoline<
            P: IsA<InstallScript>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::OsinfoInstallScript,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(InstallScript::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::product-key-format\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_product_key_format_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl<O: IsA<InstallScript>> InstallScriptExt for O {}

impl fmt::Display for InstallScript {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("InstallScript")
    }
}
